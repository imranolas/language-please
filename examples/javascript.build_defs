KARMA_CONFIG = """module.exports = function(config) {
  config.set({
    frameworks: ['jasmine'],
    files: ['%s'],
    browsers: ['PhantomJS'],
    reporters: ['junit', 'progress'],
    junitReporter: {
      outputFile: 'test.results',
      outputDir: 'test.results'
    },
    client: {
      captureConsole: true
    },
    captureTimeout: 5000,
    singleRun: true,
  });
};
"""


def js_test(name, src=None, srcs=None, deps=None, debug=True, labels=None, visibility=None, minify=False, source_maps=False):
    # Generate a js library rule for the stuff passed in, then wrap it into a binary rule and
    if src and srcs:
        raise TypeError("Only 1 of {src, srcs} can be used.")
    deps = deps or []
    labels = labels or []

    binary_name = '%s_bin' % name
    js_binary(
        name=binary_name,
        srcs=[src] if src else srcs,
        deps=deps,
        minify=minify,
        debug=debug,
        source_maps=source_maps
    )

    test_cmd = ('(export PHANTOMJS_BIN="$(location //third_party/binary:phantomjs2)" && '
                'cp $(location :%s) test.conf && '
                'karma start test.conf)') % name

    # For debug we dont need phantom as we want to test directly in the browser so we
    # use Chrome, that will get launched by karma, and we will basically run a http server
    # in http://localhost:9876/ that any browser can connect to
    test_cmd_dbg = ('cp $(location :%s) test.conf && '
                'karma start test.conf --no-single-run --browsers Chrome') % name
    gentest(
        name=name,
        outs=['%s.conf.js' % name],
        cmd='echo "%s" > $OUT' % (KARMA_CONFIG % ('$(location :%s)' % binary_name)),
        test_cmd={
            'dbg': test_cmd_dbg,
            'opt': test_cmd,
        },
        deps=[':' + binary_name],
        data=[':' + binary_name],
        tools=['//third_party/binary:phantomjs2'],
        labels=labels + ['karma'],
        visibility=visibility,
        requires=['js'],
    )


def js_binary(name, src=None, srcs=None, deps=None, visibility=None, extra_env=None, source_maps=False,
              minify=True, debug=False, browser=True, out_name=None, relay_schema=None, extract_css=False,
              outs=None, vendor=False, vendor_rule=None, cacheEnabled=True, moment_locales=['en']):
    """
    Compiles the srcs and all defined dependencies into a single JS file using webpack

    :param name: The name of the given js_binary
    :param src The source file
    :param srcs: The source file(s)
    :param deps: Required dependencies
    :param visibility: Who can access the resulting binary
    :param extra_env: Specifies additional exported environments
    :param source_maps: Specifies if source maps will be created for the resulting binary
    :param minify: Specifies if the binary will be minified or not
    :param debug: Sets the node environment to dev or prod
    :param browser: If resulting file is needed for a browser environment
    :param out_name: A separate out_name can be specified
    :param relay_schema: If the resulting binary depends on a relay schema
    :param outs: Files to output
    :param vendor: If this is a vendor binary
    :param vendor_rule: build path of the vendor binary
    :param moment_locales: list of locales to include, e.g ['en']. Pass None to include all locales
    """
    # Take all the outputs and process them into a single binary
    if src and srcs:
        raise TypeError("Only 1 of {src, srcs} can be used.")

    srcs = [src] if src else srcs
    srcs = srcs or []
    deps = deps or []

    extra_env = extra_env or []
    exports = [
        'NODE_ENV=development' if debug else 'NODE_ENV=production',
        # we tell node to get node_modules from the third_party directory.
        # using webpack arbitrarily to have one rule from that directory.
        'NODE_PATH=$(dir //third_party/js:webpack_npm)'
    ]
    exports.extend(extra_env)
    cache_dir = '$(dir //third_party/js:webpack_npm)'
    exports.append('CACHE_DIR=%s' % cache_dir)

    files = ['$(location %s)' % src if src.startswith(':') else src for src in srcs]

    out_name = out_name or "%s.js" % name
    outs = outs or [out_name]
    # Pass a flag to disable babel compacting which only works for small < 100kb files.
    flags = []
    if source_maps:
        outs = outs + ['%s.map' % out for out in outs]
    if minify:
        flags.append('--minify')
    if source_maps:
        flags.append('--src_maps')
    if not browser:
        flags.append('--node')
    if vendor:
        flags.append('--vendor')
    if cacheEnabled:
        flags.append('--cache')
    if vendor_rule:
        flags.append('--vendor_location "$(locations %s)"' % (vendor_rule))
    if relay_schema:
        deps.append(relay_schema)
        exports.append('RELAY_SCHEMA_PATH=${TMP_DIR}/$(location %s)' % relay_schema)
    if moment_locales:
        flags = flags + ['--moment_locales %s' % locale for locale in moment_locales]
    if extract_css:
        outs = outs + ['%s.css' % x for x in outs if x.endswith('.js')]
        flags.append('--extract_css')
        if source_maps:
            outs = outs + ['%s.map' % x for x in outs if x.endswith('.css')]

    plugin_dir = '$(dir //infrastructure/script/build_js/custom_babel_plugins)'
    cmd = '%s node $(location //infrastructure/script/build_js) --plugin_dir %s -o $OUTS %s %s' % (
        ' '.join('export %s;' % export for export in exports), plugin_dir,
        ' '.join(flags), ' '.join(['--src %s' % f for f in files])
    )

    js_files = filter(lambda out: out.endswith('.js'), outs)

    if len(js_files) > 1:
        cmd += ' --entries %s' % ','.join(js_files)

    genrule(
        name=name,
        srcs=srcs,
        outs=outs,
        deps=deps,
        tools=[
            '//infrastructure/script/build_js',
            '//third_party/js:webpack_npm',
            '//infrastructure/script/build_js/custom_babel_plugins',
        ],
        needs_transitive_deps=True,
        cmd=cmd,
        visibility=visibility,
        requires=['js'],
    )

def js_vendor_bundle(name, deps=None, vendor=False, visibility=None, minify=True, moment_locales=['en']):
    '''
    creates a js vendor bundle
    top tip: run the line below to see what third_party deps the binary uses
    plz query deps killik_ops_dashboard/frontend/app:compiled | tr -d ' ' | grep 'third_party/js' | sort | uniq
    '''
    deps = deps or []
    # we assume the third_party dep name will be the npm module name
    js_deps = [dep.split(':', 1)[1] for dep in deps]
    # this can get passed through to the js build script like so
    extra_env = ['VENDOR_DEPS=%s' % ','.join(js_deps)]

    js_binary(
        name=name,
        deps=deps,
        minify=minify,
        moment_locales=moment_locales,
        vendor=True,
        extra_env=extra_env,
        outs=['%s.js' % name, '%s-manifest.json' % name],
        visibility=visibility
    )


def js_library(name, src=None, srcs=None, deps=None, visibility=None):
    if src and srcs:
        raise TypeError("Only 1 of {src, srcs} can be used.")

    filegroup(
        name=name,
        srcs=[src] if src else srcs,
        deps=deps,
        output_is_complete=False,
        visibility=visibility,
        requires=['js'],
    )


def npm_library(name, version=None, deps=None, visibility=None, package_name=None,
                no_parse=None, post_install_cmd=None, out_name=None, licences=None,
                package_file=None, shrinkwrap_file=None, patch=None, native=False,
                android_deps=None, labels=None):
    """Install an NPM library into the third_party directory.

    Args:
      :param name: Name of the build rule.
      :param version: Version of library to install. Currently unused.
      :param package_name: Name of the npm package to install. Defaults to the same as 'name'.
      :param deps: List of rules this library depends on.
      :param no_parse: List of files withing this package which should not be parsed while building a binary.
      :param post_install_cmd: A shell command to run after the package install
      (ran with the installed dir as the cwd).
      :param visibility: The target visibility
      :param licences: Licences this library is subject to.
      :param package_file: Path to file to use for package.json. Defaults to shrinkwrap/<name>.json.
      :param shrinkwrap_file: Path to file to use for npm-shrinkwrap.json. Defaults to shrinkwrap/<name>.npm-shrinkwrap.json.
      :param patch: Path to a patch file to apply after installation.
      :param native: If True, we generate sub-rules to compile Java / Objective-C code.
      :param android_deps: Dependencies for Android / Java sub-targets.
      :param labels: Data to expose to the graph so tools can access it
    """
    deps = deps or []
    package_name = package_name or name
    out_name = out_name or name
    no_parse = no_parse or []
    post_build = None
    labels = labels or []
    labels += ['npm_package:%s@%s' % (name, version)]

    no_parse = ['%s/%s' % (package_name, f) for f in no_parse]

    # Copy both the package.json and the npm-shrinkwrap
    cmd = [
        'cp $SRCS_PACKAGE package.json',
        'cp $SRCS_SHRINKWRAP npm-shrinkwrap.json',
    ]

    # NPM install
    cmd += ['npm install --no-bin-links --no-optional --loglevel=error']

    if no_parse:
        cmd += ['echo %s > node_modules/%s/.noParse' % ('\n'.join(no_parse), name)]

    if patch:
        cmd.append('patch -p1 -d node_modules/%s < $SRCS_PATCH' % name)

    if post_install_cmd:
        cmd += ['cd node_modules/%s' % name, post_install_cmd, 'cd ../..']

    if out_name != 'node_modules':
        cmd += ['mv node_modules/%s $OUT' % name]
    if not licences:
        cmd += [
            'node -p "var fs = require(\'fs\'); '
            'process.stdout.write(\'Licence: \'); '
            'var p = JSON.parse(fs.readFileSync(\\"${OUT}/package.json\\", \'utf8\')); '
            'p.licenses ? p.licenses.map(function(o) { return o.type; }).join(\' | \') : '
            'p.license && p.license.type ? p.license.type : p.license"'
        ]

    build_rule(
        name='%s_npm' % name,
        srcs={
            'package': [package_file or 'shrinkwrap/%s.json' % package_name],
            'shrinkwrap': [shrinkwrap_file or 'shrinkwrap/%s.npm-shrinkwrap.json' % package_name],
            'patch': [patch] if patch else [],
        },
        cmd='&&'.join(cmd),
        outs=[out_name],
        labels=labels,
        requires=['js'],
        post_build=append_licences if not licences else None,
        visibility=visibility,
    )

    provides = {}
    if native:
        android_library(
            name = '_%s#java' % name,
            src_dir = ':%s_npm' % name,
            # Hardcoding this here sucks a bit but it also sucks to repeat it everywhere.
            deps=android_deps or ['//third_party/android:react-native'],
            visibility=visibility,
        )
        provides['java'] = ':_%s#java' % name
        provides['dex'] = ':_%s#java_ldex' % name
        # TODO(pebers): Add Objective-C version too.

    genrule(
        name=name,
        cmd='true',
        tools=[':%s_npm' % name],
        deps=deps,
        visibility=visibility,
        provides=provides,
    )


def append_licences(name, output):
    """Post-build callback to annotate a rule with licences read from package.json."""
    for line in output:
        if line.startswith('Licence: '):
            if line.endswith('undefined'):
                log.warning('Unable to find licence for %s', name)
            else:
                for licence in line[9:].split(' | '):
                    add_licence(name, licence)


def node_binary(name, srcs, deps=None, visibility=None):
    deps = deps or []
    outs = []
    cmd = []

    for file_name in srcs:
        outs += [file_name]
        cmd += ['cp $TMP_DIR/$PKG/%s $TMP_DIR/%s' % (file_name, file_name)]

    genrule(
        name=name,
        srcs=srcs,
        outs=outs,
        deps=deps,
        needs_transitive_deps=False,
        cmd=' && '.join(cmd),
        visibility=visibility,
    )


def js_closure_binary(name, srcs=None, out=None, entry_point=None, deps=None, visibility=None,
                      flags=None, compiler='//third_party/binary:closure_compiler'):
    """Compiles a set of Javascript files with the Closure compiler.

    Args:
      name (str): Name of the rule.
      srcs (list): Javascript source files.
      out (str): Name of output file.
      entry_point (str): Entry point to begin compilation at.
      deps (list): Dependencies of this rule.
      visibility (list): Visibility specification.
      flags (list): Extra flags to pass to the compiler.
      compiler (str): Target to use for the compiler.
    """
    cmd = ['java -jar $TOOL --js_output_file $OUT']
    if flags:
        cmd.extend(flags)
    if entry_point:
        cmd.append('--entry_point ' + entry_point)
    cmd.append('$SRCS')
    build_rule(
        name = name,
        outs = [out or name + '.js'],
        srcs = srcs,
        cmd = ' '.join(cmd),
        deps = deps,
        tools = [compiler],
        requires = ['js'],
        visibility = visibility,
    )
